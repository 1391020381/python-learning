# Python基础
* 以 # 号 开头的语句是注释,可以是任意内容。
* '''  '''    """  """  多行注释
* #coding=utf-8
* #-*- coding:utf-8 -*-
* 一个语句以冒号 ：结尾时,缩进的语句视为代码块
* 大小写敏感
## 数据类型和变量
 1. 数据类型
   * 整数
   * 浮点数
   * 字符串  转义符 \  input()输入的是字符串
      * print('''line1
...line2
....line3''')
   * 布尔值  True False   
      *  and or not运算
   * 空值 None   
  2. 变量 
    * 同一个变量可以反复赋值,而且可以是不同的类型的变量。
    * a = 'ABC'
      * 在内存中创建一个 'ABC'的字符串
      * 在内存中创建一个名为 a的变量,并把它指向 'ABC'
  3. 常量    
     * 通常用全部大写的变量名表示常量
  ## 小结
   * Python 支持多种数据类型,在计算机内部,可以把任意数据都看成一个'对象',而变量就是在程序中用来指向这些数据对象的， 对变量赋值就是把数据和变量给关联起来。
   * 对变量赋值 x =y 是把变量 x指向真正的对象,该对象是变量y所指向的。  随后对变量 y的赋值不影响变量 x的指向。
   * python 的整数没有大小限制,浮点数也没有但超出一定范围直接限时inf
 ## 字符编码和编码   
 * 因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。
 * ASCII  GB    2312  Unicode  UTF-8
   * 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。
   * Python对bytes类型的数据用带b前缀的单引号或双引号表示：x = b'ABC'要注意区分'ABC'和b'ABC'，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。
   *  #!/usr/bin/env python3 为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；
   *  # -*- coding: utf-8 -*-  告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。
   * 格式化输出
     * %
     * format()
## 使用list和 tuple
1. list是一种有序的集合，可以随时添加和删除其中的元素   
   * list 是一个可变的有序表，list 里面的元素的数据类型也可以不同,也可以是个List
   * items.append('a') 追加
   * items.insert(1,'a')   插入
   * items.pop() 删除List末尾的元素
   * itmems.pop(i) 删除指定位置的元素
   * 都改变原来的List
 2. 元组 tuple 一旦初始化就不能修改.
   * 无 append() insert方法  
   * oTuple = (1,2,3) 
   * 只有一个元素的tuple定义时必须加个逗号  oTuple = （1,）
   * 理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。
## 条件判断 
   * if else elif  
   * input() 返回的数据类型是str  str不能直接和整数比较，必须先把str转换成整数。Python提供了int()函数来完成这件事情
## 循环   
  * for in
  * while
  * break 在循环中，break语句可以提前退出循环
  * continue 在循环过程中，也可以通过continue语句，跳过当前的这次循环，直接开始下一次循环
## 使用dict和set  
1. dict <字典  {a:1,b:3}>  
  * in判断Key是否
  * d.get('a') 通过dict提供的get()方法，如果key不存在，可以返回None
  * d.pop('a')
  * dict内部存放顺序和Key放入的顺序是没有关系的
  * dict的key必须是不可变对象。
  *  通过key计算位置的算法称为哈希算法（Hash）。
# 函数
 ## 定义函数
  * 在Python中定义一个函数要使用def语句,一次写出函数名、括号、括号中的参数冒号：然后,在缩进中编写函数体,函数的返回值用retrun 语句返回
  ```
  # -*- coding: utf-8 -*-
  def my_abs(x):
      if x >=0:
          return x
      else:
          return -x    
  ```  
   * 空函数  
      * pass
   * 参数的检查
      * raise TypeError('bad operand type')
   * 返回多个值
      * 返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple   
      * 函数执行完毕也没有return 语句时,自动return None
## 函数的参数
  * 位置参数
  * 默认参数
    * Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。
    * 为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。
  * 可变参数  
    * 定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数     
    * *nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。 
  * 关键字参数
    * 可变参数允许你传入0个或任意个参数,这些参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数数名的参数,这个关键字参数在函数内部自动组装为一个dict
    * def person(name,age,***kw)   
  * 命名关键字参数
    * def person (name,age,*,city,job)  
    * 和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。
    *  person('Jack', 24, city='Beijing', job='Engineer')
    * 如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：
    *  def person(name, age, *args, city, job):
  * 参数组合
    * 在Python中定义函数,可以用 必选参数 默认参数,可以变参数,关键字参数 都可以组合使用  
  * 小结
    * 默认参数一定要用不可变对象
    *  *args  可变参数 args接受的是一个 tuple
    *  **kw 关键字参数 kw 接受的是一个dict 
    * 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；
    * 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{'a': 1, 'b': 2})。 
    * 定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。
    ## 递归函数
  # 高级特性  
   ## 切片 取一个list或 tuple的部分元素是非常常见的操作
   * L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。
   * L = [1,2,3,4]
   * L[:10]
   * L[-10:]
   * L[10:20]
   * L[:10:2] 前10个数,每两个取一个
   * L[:] 复制一个L
   * tuple也可以用切片操作，只是操作的结果仍是tuple：
## 迭代
 * list tuple dict set str
 * generator 
 * isinstance()判断一个对象是否 Iterable对象
 * form collection import Iterable
 * isinstance([],Iterable)
# 函数式编程
  * 函数式编程的一个特点就是,允许把函数本身作为参数传入另一个函数,还允许返回一个函数
  * 高阶函数
     * map() reduce()     list() 
     * filter() sorted()
     * lambda x: x%n>0  
     * 返回函数
       * 高阶函数除了可以接受函数作为参数外,还可以把函数作为结果值返回
       * 闭包 
       * 返回的函数并没有立刻执行,而是知道调用了f()才执行
       * 
  ```
           def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
    return fs
     
  ```
* 匿名函数
 * lambda x:x*x
 * 匿名函数有个限制,就是只能有一个表达式,不用写return 返回值就是该表达式的结果
 * 可以把一个匿名函数赋值给一个变量,再利用变量调用该函数
* 装饰器
  * 函数对象有一个__name__ 属性可以拿到函数的名字 
  * 因为我们讲了函数也是对象，它有__name__等属性，但你去看经过decorator装饰之后的函数，它们的__name__已经从原来的'now'变成了'wrapper'
  * functools.wraps
 * 偏函数 
  *  Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。要注意，这里的偏函数和数学意义上的偏函数不一样。   
  * functools.partial就是帮助我们创建一个偏函数的
  * 简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。
  * 当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。
 # 模块 
  * 内置模块 第三方模块
  * 如果不同的人编写的模块名相同怎么办？为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）
  * 
 ```
 mycompany
├─ __init__.py
├─ abc.py
└─ xyz.py
 ```
 * 引入了包以后只要顶层的包名不与别人冲突,那所有模块都不会与别人冲突。现在,abc.py 模块的名字就变成了mycompany.abc 类似的,xyz.py的模块变成了mycompany.xyz
 * 请注意,每个包目录下面都会有一个__init__.py的文件,这个文件必须存在,否则,Python就把这个目录当成普通目录,而不是一个包 。__init__py 可以是空文件,也可以有Python代码，因为__init__.py本身就是一个模块，而它的模块名就是mycompany。 
 * 自己创建模块时要注意命名，不能和Python自带的模块名称冲突。例如，系统自带了sys模块，自己的模块就不可命名为sys.py，否则将无法导入系统自带的sys模块。   
 * 当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。
 ## 作用域
  * 在一个模块中,通过_ 前缀来实现私有变量
  * 类似 __xxx__这样的变量是特殊变量,可以被直接引用,但有特殊用途,比如上面的__author__
  * private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。
##安装第三方模块
 * 在Python中,安装第三方模块,是通过包管理工具pip完成的。
 * 在 Mac或者 Linux安装 pip本身这个步骤就可以跳过了。
 * 如果你在使用Windows，确保安装时勾选了pip和 Add python.exe to path 
 * 在命令提示符窗口下尝试运行pip，如果Windows提示未找到命令，可以重新运行安装程序添加pip
 * Anaconda
 * 模块搜索路径
   * 默认情况下,Python解释器会搜索当前目录,所有已安装的内置模块和第三方模块,搜索路径存放在sys模块的path变量中 
   *  Python版本的控制和第三方模块的管理
# 面向对象   